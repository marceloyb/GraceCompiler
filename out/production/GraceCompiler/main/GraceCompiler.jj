options{
  LOOKAHEAD=8;
  UNICODE_INPUT=true;
}

PARSER_BEGIN(GraceCompiler)

package main;
import java.util.Stack;
import java.io.*;
import main.semantic.*;
import main.semantic.commands.*;
import java.util.ArrayList;
import java.util.List;
import main.exceptions.*;

public class GraceCompiler{

  public static Stack<SymbolList> stackRoot = new Stack<SymbolList>();
  public static int symbolListCount = 0;

  public static void main(String args[]){
    try{
        GraceCompiler parser = new GraceCompiler(new java.io.FileInputStream(args[0]));
        parser.startParsing();

    } catch (Throwable error){
        System.out.println("Syntax Error\n" + error.getLocalizedMessage());
    }
  }

}

PARSER_END(GraceCompiler)

SKIP :
{
  " "
| "\t"
| "\r"
| <"//" (~["\r", "\n"])*>
| "\n"
}

TOKEN :
{

  // definitions
    <_DEF: "def">
    |<_VAR: "var">
    |<_TYPE: "int" | "bool" | "string" | "void">

    // primitives

    |<_BOOL: "true" | "false">
    |<_NUMBER: (["0"-"9"])+>
    |<_STR: ["\""] (<_CHAR> | <_NUMBER> | " ")* ["\""]>



  //  operators and symbols

    |<_LPAR: "(">
    |<_RPAR: ")">
    |<_LBRACE: "{">
    |<_RBRACE: "}">
    |<_LBRACK: "[">
    |<_RBRACK: "]">
    |<_COMMA: ",">
    |<_SEMICOLON: ";">
    |<_ARIT: "+" | "-" | "*" | "/" | "%">
    |<_RELAC: ">" | ">=" | "<" | "<=">
    |<_EQUALITY: "==" | "!=">
    |<_LOGICAL: "||" | "&&" | "!">
    |<_ASSIGN: ("=" | "+=" | "-=" | "*=" | "/=" | "%=")>
    |<_COND: "?">
    |<_COLON: ":">

  // cmds

    | <_IF: "if">
    | <_ELSE: "else">
    | <_FOR: "for">
    | <_WHILE: "while">
    | <_READ: "read">
    | <_WRITE: "write">
    | <_SKIP: "skip">
    | <_STOP: "stop">
    | <_RETURN: "return">


    | <_ID: <_CHAR> (<_CHAR> | <_NUMBER>)*>
    |<_CHAR: ["a"-"z"] | ["A" - "Z"] | ["_"]>


}

void startParsing():
{
  double a;
}
{
  GLOBAL_START()
  {
    System.out.println ("Compilation Finished");
  }
}

void GLOBAL_START():
{
    SymbolList rootList = new SymbolList(null, null);
    GraceCompiler.stackRoot.push(rootList);
    List<Var> globalVarList = new ArrayList<Var>();;
}
{
    globalVarList = VAR_SECTION(rootList) {rootList.setVarList(globalVarList);} MAIN_START(rootList)
    {
    }
}

void MAIN_START(SymbolList list):
{
    List<Var> mainVarList = new ArrayList<Var>();
    SymbolList mainSymbolList = new SymbolList(list, mainVarList);
    SymbolList backup = GraceCompiler.stackRoot.peek();
}
{
    SUBPROGRAM(list)
    {
    }
}

// Variable declaration rule
// NO COMEÇO DO RETURN DO VAR ROOT EU ATUALIZO O VALOR DA LISTA
// PARA O PRIMEIRO CASO ISSO É O CERTO POREM PARA O SEGUNDO PREJUDICA A ANALISE SEMANTICA
List<Var> VAR_ROOT(SymbolList list):
{
    Integer counter = 0;
    Var var = new Var();
    Token typeToken;
    List<Var> listOfVar = new ArrayList<Var>();
}
{
    listOfVar = VAR_ADD(list) <_COLON> typeToken = <_TYPE> <_SEMICOLON>
    {
        Type type = Type.valueOf(typeToken.toString().toUpperCase());
        System.out.println(type);

//        OLHA TODAS AS VARIAVEIS DA LISTA DE VARIAVEIS, VE SE ELA REFERENCIA ALGUMA QUE JA FOI DECLARADA
//        SE ELA NAO REFERENCIA ATUALIZA O TIPO PRO TIPO QUE FOI PASSADO AQUI NO VAR_ROOT
//        SE ELA REFERENCIA PASSA POR TODAS E VE SE O TIPO É IGUAL O DO TIPO PASSADO AQUI NO VAR ROOT
//        SE NAO FOR É FALHA SEMANTICA
        for (Var v: listOfVar){
            if (v.getReferencia() == false){
                v.setType(type);
            }
            else if (v.getReferencia() == true && !v.getType().equals(type)){
                System.out.print("Semantic error: ");
                System.out.println("the declaration of variable " + v.getId() + " is not valid, type error");
            }
        }

        if (list.getVarList() != null){
            for (Var v: listOfVar){
                System.out.println(v.getId());
                list.addToList(v);
            }
        }
        else{
            list.setVarList(listOfVar);
        }
        System.out.println("terminando var root");
        return listOfVar;
    }
}

List<Var> VAR_ADD(SymbolList list):
{
    List<Var> listOfVar = new ArrayList<Var>();
    Var var = new Var();
    Token id;
    List<Var> recursiveListOfVar = null;
    String idString;
    String val = new String();
    Type initialized = Type.VOID;
}
{
    id = <_ID> (<_ASSIGN> initialized = TERM(list))* (<_COMMA> recursiveListOfVar = VAR_ADD(list))?
    {
        idString = id.toString();
        var.setType(initialized);
        System.out.println(idString);

        if (initialized != Type.VOID){
            var.setReferencia(true);
        }

        var.setId(idString);
        listOfVar.add(var);

        if (recursiveListOfVar != null){
            for(Var v: recursiveListOfVar){
                listOfVar.add(v);
            }
        }
        System.out.println("terminando var add");
        return listOfVar;
    }
}

List<Var> VAR_SECTION(SymbolList list):
{
    List<Var> varList = null;
    List<Var> recursiveVar = null;
}
{
    <_VAR> varList = VAR_ROOT(list) (recursiveVar = VAR_SECTION(list))?

    {
        if (recursiveVar != null){
            varList.addAll(recursiveVar);
            System.out.println("VARIAVEL RECUSIVA");
        }
        System.out.println("saiu no var section");
        return varList;
    }
}

Type TERM(SymbolList list):
{
    Type returnVal = Type.VOID;
    Type type = null;
    Token id = null, number = null, bool = null, str = null;
    Var idObj = null;
}
{
    (number = <_NUMBER> | bool = <_BOOL> | str = <_STR> | id = <_ID>)
    {
        if (number != null){
            returnVal = Type.INT;
        }

        if (bool != null){
            returnVal = Type.BOOL;
        }

        if (str != null){
            returnVal = Type.STRING;
        }

        if (id != null){

            idObj = list.getVar(id.toString());
            if (idObj != null){
                returnVal = idObj.getType();
            }
            else{
                System.out.println("Error on variable \"" + id.toString() + "\"");
                throw new UndeclaredId();

            }
        }
        System.out.println("saindo term");
        return returnVal;
    }
}

SubProgram SUBPROGRAM(SymbolList list):
{
    SubProgram subProg = new SubProgram();
    List<Var> parameterList = new ArrayList<Var>();
    SymbolList subProgramList = new SymbolList(list, parameterList);
    List<Var> subProgramVar = new ArrayList<Var>();
    Token typeToken = null;
    Token idToken = null;
    Type subProgType = Type.VOID;
}
{
    (<_DEF> idToken = <_ID> <_LPAR> (parameterList = PARAMETER_LIST())? <_RPAR> (<_COLON> typeToken = <_TYPE>)? {
    {
        if (typeToken != null)
            subProgType = General.updateType(typeToken);
        for (Var v: list.getVarList()){
            parameterList.add(v);
        }
    }
        subProgramList.setVarList(parameterList);
    }BLOCK(subProgramList, subProgType)
    )
    {
        subProg.setSubSymbolList(subProgramList);
        subProg.setId(idToken.toString());
        if (typeToken != null){
            subProg.setType(General.updateType(typeToken));
        }
        return subProg;
    }
}

List<Var> PARAMETER_LIST():
{
    List<Var> parameterList = new ArrayList<Var>();
    List<Var> recursiveList = null;
    Token typeToken;
    Type returnType = Type.VOID;
}
{
    parameterList = PARAMETER_ADD() <_COLON> typeToken = <_TYPE> (<_SEMICOLON> recursiveList = PARAMETER_LIST())?
    {

        returnType = General.updateType(typeToken);

        for (var v: parameterList){
            v.setType(returnType);
        }

        if (recursiveList != null){
            for (var v: recursiveList){
                parameterList.add(v);
            }
        }

        for (var v: parameterList){
            System.out.println(v.getId() + " " + v.getType());
        }
        System.out.println("saindo do parameter list");
        return parameterList;
    }
}

List<Var> PARAMETER_ADD():
{
    Var parameter = new Var();
    List<Var> parameterList = new ArrayList<Var>();
    List<Var> recursiveList = new ArrayList<Var>();
    Token idToken;
    boolean composed = false;
}
{
    (idToken = <_ID> <_LBRACK> <_RBRACK> (<_COMMA> recursiveList = PARAMETER_ADD())? {composed = true;}
    | idToken = <_ID> (<_COMMA> recursiveList = PARAMETER_ADD())?)
    {
        System.out.println("entrou no parameter add");
        parameter.setId(idToken.toString());
        parameter.setComposed(composed);
        if (recursiveList != null){
            for (var v: recursiveList){
                parameterList.add(v);
            }
        }
        parameterList.add(parameter);
        System.out.println("saindo do parameter add");
        return parameterList;
    }
}

void BLOCK(SymbolList subProgramList, Type blockType):
{
    List<Var> subProgVarList = new ArrayList<Var>();
}
{
    <_LBRACE> (subProgVarList = VAR_SECTION(subProgramList)
    {
        for (Var v: subProgVarList){
            subProgramList.getVarList().add(v);
        }
    })? (STATEMENT(subProgramList, blockType))? <_RBRACE>
    {
        System.out.println("entrou no block");
    }
}

void STATEMENT(SymbolList subProgramList, Type blockType):
{
}
{
    (SUBPROGRAM(subProgramList) | COMMAND(subProgramList, blockType)) (STATEMENT(subProgramList, blockType))?
    {
        System.out.println("entrou no steatement");
    }
}

void COMMAND(SymbolList subProgramList, Type blockType):
{
    Type commandType = null;
}
{
    commandType = ATTRIBUTION(subProgramList) | commandType = IF(subProgramList) | commandType = WHILE(subProgramList)
    | SKIP_CMD(subProgramList, blockType) | STOP_CMD(subProgramList, blockType) | RETURN(subProgramList, blockType)
    {
    }
}

void RETURN(SymbolList subProgramList, Type blockType):
{
    Token returnToken = null;
    Type blockTypeVal = Type.VOID;
}
{
    returnToken = <_RETURN> blockTypeVal = EXPRESSION(subProgramList) <_SEMICOLON>
    {
        if(blockType != Type.VOID && !blockTypeVal.equals(blockType)){
            System.out.println("Semantic error: Block RETURN type is not the same of the declaration");
        }
    }
}

void SKIP_CMD(SymbolList subProgramList, Type blockType):
{
}
{
    <_SKIP> <_SEMICOLON>
    {
        if (blockType != Type.WHILE && blockType != Type.FOR){
            System.out.println("Syntactic error: Bad use of SKIP command");
        }
    }
}

void STOP_CMD(SymbolList subProgramList, Type blockType):
{
}
{
    <_STOP> <_SEMICOLON>
    {
        if (blockType != Type.WHILE && blockType != Type.FOR){
            System.out.println("Syntactic error: Bad use of STOP command");
        }
    }
}

Type ATTRIBUTION(SymbolList subProgramList):
{
    Token idToken = null;
    Type idType = Type.VOID;
    Type assignType = Type.VOID;
    Type assignTypeComposed = Type.VOID;
    List<Var> varList = subProgramList.getVarList();
}
{
    idToken = <_ID> (<_LBRACK> <_RBRACK>)? <_ASSIGN> assignType = EXPRESSION(subProgramList) <_SEMICOLON>
    {
        for(Var v: varList){
            if (v.getId().equals(idToken.toString())){
                idType = v.getType();
            }
        }
        if (idType != Type.VOID && !idType.equals(assignType)){
            System.out.println("Semantic error. Uncompatible type in attribution of variable " + idToken.toString());
        }

        return idType;
    }
}

Type IF(SymbolList subProgramList):
{
    Type testType = Type.VOID;
    Type elseType = Type.VOID;
}
{
    <_IF> <_LPAR> testType = EXPRESSION(subProgramList) <_RPAR> BLOCK(subProgramList, Type.VOID) (elseType = ELSE(subProgramList))
    {
        if (testType != Type.BOOL){
            System.out.println("Semantic error: Expression in IF command must be of BOOLEAN type");
        }
        return testType;
    }
}

Type ELSE(SymbolList subProgramList):
{
    Type ifType = Type.VOID;
}
{
    <_ELSE> (ifType = IF(subProgramList) | BLOCK(subProgramList, Type.VOID))
    {
        return ifType;
    }
}

Type WHILE(SymbolList subProgramList):
{
    Type testType = Type.VOID;
}
{
    <_WHILE> <_LPAR> testType = EXPRESSION(subProgramList) <_RPAR> BLOCK(subProgramList, Type.WHILE)
    {
        return testType;
    }
}

//Type FOR(SymbolList subProgramList):
//{
//    Type atribType = Type.VOID;
//    Type atribExpress = Type.VOID;
//    Type atribPass = Type.VOID;
//}
//{
//    <_FOR> <_LPAR> atribType = ATTRIBUTION(subProgramList) atribExpress = EXPRESSION(subProgramList) <_SEMICOLON>
//    atribPass = ATTRIBUTION(subProgramList) BLOCK(subProgramList, Type.FOR)
//    {
//
//    }
//}

Type EXPRESSION(SymbolList subProgramList):
{
    Type expressionType = Type.VOID;
    OperationType operationValue = OperationType.VOID;
}
{
    operationValue = OPERATION(subProgramList)
    {
        if (!operationValue.equals(OperationType.VOID)){
            if(operationValue.equals(OperationType.ARIT)){
                expressionType = Type.INT;
            }
            else expressionType = Type.BOOL;
        }
        return expressionType;
    }
}

OperationType OPERATION(SymbolList subProgramList):
{
    Type firstTerm = Type.VOID;
    Type secondTerm = Type.VOID;
    OperationType firstTermOp = OperationType.VOID;
    OperationType secondTermOp = OperationType.VOID;
    OperationType opType = OperationType.VOID;
    Token operationToken = null;
    Token firstTermToken = null;
    Token secondTermToken = null;
}
{
    (firstTerm = TERM(subProgramList) | <_LPAR> firstTermOp = OPERATION(subProgramList))
    ((operationToken = <_ARIT> | operationToken = <_RELAC> | operationToken = <_EQUALITY> | operationToken = <_LOGICAL>)
    (secondTerm = TERM(subProgramList) | <_LPAR> secondTermOp = OPERATION(subProgramList)))?
    {
        if(operationToken != null){
            if (!firstTermOp.equals(OperationType.VOID)){
                if(firstTermOp.equals(OperationType.ARIT)){
                    firstTerm = Type.INT;
                }
                else firstTerm = Type.BOOL;
            }

            if (!secondTermOp.equals(OperationType.VOID)){
                if(secondTermOp.equals(OperationType.ARIT)){
                    secondTerm = Type.INT;
                }
                else secondTerm = Type.BOOL;
            }

            if(!firstTerm.equals(secondTerm)){
                System.out.println("Semantic error: " + operationToken.toString() + " is impossible with " + firstTerm + " and " + secondTerm);
            }

            opType = General.updateOperationType(operationToken);
        }
        else{
            if(firstTerm.equals(Type.INT)){
                opType = OperationType.ARIT;
            }
            else{
                opType = OperationType.LOGIC;
            }
        }
        return opType;
    }
}