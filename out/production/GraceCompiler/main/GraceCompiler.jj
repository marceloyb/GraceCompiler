options{
  LOOKAHEAD=6;
  UNICODE_INPUT=true;
}

PARSER_BEGIN(GraceCompiler)

package main;
import java.util.Stack;
import java.io.*;
import main.semantic.*;
import java.util.ArrayList;
import java.util.List;
import main.exceptions.*;

public class GraceCompiler{

  public static Stack<SymbolList> stack = new Stack<SymbolList>();

  public static void main(String args[]){
    try{
        GraceCompiler parser = new GraceCompiler(new java.io.FileInputStream(args[0]));
        parser.startParsing();

    } catch (Throwable error){
        System.out.println("Syntax Error\n" + error.getMessage());
    }
  }

}

PARSER_END(GraceCompiler)

SKIP :
{
  " "
| "\t"
| "\r"
| <"//" (~["\r", "\n"])*>
}

TOKEN :
{

  // definitions
    <_DEF: "def">
    |<_VAR: "var">
    |<_TYPE: "int" | "bool" | "string" | "void">

    // primitives

    |<_BOOL: "true" | "false">
    |<_NUMBER: (["0"-"9"])+>
    |<_STR: ["\""] (<_CHAR> | <_NUMBER> | " ")* ["\""]>



  //  operators and symbols

    |<_LPAR: "(">
    |<_RPAR: ")">
    |<_LBRACE: "{">
    |<_RBRACE: "}">
    |<_LBRACK: "[">
    |<_RBRACK: "]">
    |<_COMMA: ",">
    |<_SEMICOLON: ";">
    |<_SUM: "+">
    |<_SUB: "-">
    |<_MULT: "*">
    |<_DIV: "/">
    |<_MOD: "%">
    |<_EQUAL: "==">
    |<_NEQUAL: "!=">
    |<_GTHAN: ">">
    |<_LTHAN: "<">
    |<_GEQUAL: ">=">
    |<_LEQUAL: "<=">
    |<_LOG_OR: "||">
    |<_LOG_AND: "&&">
    |<_LOG_NOT: "!">
    |<_ASSIGN: "=">
    |<_SUM_ASSIGN: "+=">
    |<_SUB_ASSIGN: "-=">
    |<_MULT_ASSIGN: "*=">
    |<_DIV_ASSIGN: "/=">
    |<_MOD_ASSIGN: "%=">
    |<_COND: "?">
    |<_COLON: ":">

  // cmds

    | <_IF: "if">
    | <_ELSE: "else">
    | <_FOR: "for">
    | <_WHILE: "while">
    | <_READ: "read">
    | <_WRITE: "write">
    | <_SKIP: "skip">
    | <_STOP: "stop">
    | <_RETURN: "return">


    | <_ID: <_CHAR> (<_CHAR> | <_NUMBER>)*>
    |<_CHAR: ["a"-"z"] | ["A" - "Z"] | ["_"]>


}

void startParsing():
{
  double a;
}
{

  VAR()
}

void MAIN_START():
{
    SymbolList rootList = new SymbolList(null, null);
    GraceCompiler.stack.push(rootList);
}
// declaração das variáveis da main
{
    {
    }
}

// Variable declaration rule
void VAR():
{
    Var var = new Var();
    Token typeToken;
    List<Var> listOfVar = new ArrayList<Var>();
}
{
    <_VAR> listOfVar = VAR_ADD() <_COLON> typeToken = <_TYPE> <_SEMICOLON>
    {

        Type type = Type.valueOf(typeToken.toString().toUpperCase());
        General.updateVar(listOfVar, type);
        for (Var v: listOfVar){
            System.out.println(v.getId().toString());
            System.out.println(v.getType().toString());
        }
    }
}

List<Var> VAR_ADD():
{
    List<Var> listOfVar = new ArrayList<Var>();
    Var var = new Var();
    Token id;
    String idString;
    String val = new String();
}
{
    (id = <_ID> (<_ASSIGN> (<_NUMBER> | <_CHAR>)*)*)
    {
        idString = id.toString();
        var.setId(idString);
        listOfVar.add(var);
        return listOfVar;
    }
}

void EXPRESSION():
{
    Content content = null;
}
{
    content = TERM()
}

Content TERM():
{
    SymbolList list = GraceCompiler.stack.peek();
    Integer numVal = null;
    Boolean boolVal = null;
    String strVal = null;
    Content idObj = null;

    Type type = null;
    Content content = null;
    Token id = null, number = null, bool = null, str = null;
}
{
    (number = <_NUMBER> | bool = <_BOOL> | str = <_STR> | id = <_ID>)
    {
        if (number != null){
            numVal = Integer.valueOf(number.toString());
            content.setContent(numVal);
            content.setType(Type.INT);
        }

        if (bool != null){
            boolVal = Boolean.valueOf(bool.toString());
            content.setContent(boolVal);
            content.setType(Type.BOOL);
        }

        if (str != null){
            strVal = str.toString();
            content.setContent(strVal);
            content.setType(Type.STRING);
        }

        if (id != null){
            idObj = list.getValue(id.toString());
            if (idObj != null){
                content = idObj;
            }
            else{
                throw new UndeclaredId();
            }
        }

        return content;
    }
}